# Немного теории
### Что такое GitHub?
GitHub — это самый популярный сервис для публичного хранения репозиториев. Репозитории опенсорсных проектов в GitHub видны всем — можно делать копии основной ветки (это называется форкнуть, сделать форк; от англ. __fork__ — вилка, ответвление), чтобы что-то изменить и после предложить свои изменения автору проекта.

### Что такое Git? 
Git — это система контроля версий, которая позволяет нескольким разработчикам одновременно работать над одним продуктом.
### Зачем нужен Git?
В Git хранятся все версии проекта — как бы по вертикали. Они называются коммитами (от англ. __commit__ — совершать, фиксировать). Такая система позволяет вернуться к любой сохранённой версии при необходимости, например, если новый коммит не работает.

А ещё Git позволяет работать над одним кодом десяткам и даже тысячам людей — как бы по горизонтали. В таком случае каждый разработчик получает свою версию кода, вносит в неё изменения и отправляет обратно. Коммиты разных программистов объединяются — мёржатся (от англ. __merge__ — сливать, соединять). У каждого коммита есть уникальный номер, он называется хешем, и комментарий, который описывает суть изменений. А все коммиты в одном проекте складываются в единую структуру — бранч (от англ. __branch__ — отделение, ветка). 

Ветвь — это параллельная версия вашего репозитория (проекта). По умолчанию в вашем репозитории есть одна главная ветвь с именем main (англ. __main__ — основной, главный). Вы можете создавать дополнительные ветви от ветки main в своём репозитории, что позволяет одновременно разрабатывать разные версии проекта. В дополнительных ветвях вы можете вносить изменения, не влияя на main версию, то есть обеспечивая её безопасность.

Важное преимущество Git-проектов состоит ещё и в том, что код хранится и на сервере, и локально, то есть на компьютерах разработчиков. Это значит, что код нельзя случайно (или специально) удалить — всегда найдётся версия, из которой можно восстановить сразу всё.
### Одновременная работа над одним и тем же
Например, один разработчик ищет баг в коде и чуть переписывает несколько строк, а другой берёт и удаляет весь кусок кода целиком. В таком случае во время коммита последнего разработчика возникнет конфликт версий: Git остановит мёрж и предложит программистам самим разобраться, что делать с конфликтным куском кода.

Но обычно разработчики не коммитят в основную ветку, чтобы случайно не нарушить работоспособность проекта. Они могут днями и даже годами коммитить в свои ветки, синхронизируя их с основной и проверяя работоспособность решений, и после релизить изменения в основную — её часто называют мастером. Но в западном мире уже говорят main.
# Практика
Полезным будет предварительно пройти [вводный курс от GitHub](https://github.com/skills/introduction-to-github). 

[Шпаргалка по Git](https://training.github.com/downloads/ru/github-git-cheat-sheet/) от GitHub на русском языке.

### Установка Git
Открываем шпаргалку и скачиваем Git на нужную систему, переходя по первым ссылкам. [Руководство к установке](https://git-scm.com/book/ru/v2/Введение-Установка-Git).
### Первоначальная настройка Git
Выполняем все пункты [руководства](https://git-scm.com/book/ru/v2/Введение-Первоначальная-настройка-Git), можно пропустить _выбор редактора_ и _настройку ветки по умолчанию_.
### Создание Git-репозитория
У нас есть 2 варианта: превратить локальный каталог в репозиторий Git или клонировать существующий репозиторий Git.

[Руководство](https://git-scm.com/book/ru/v2/Основы-Git-Создание-Git-репозитория).
#### Создание репозитория в существующем каталоге
Находим в руководстве команду для нашей системы, с её помощью переходим к каталогу, который хотим сделать репозиторием, и инициализируем его через `git init` [если перейти к каталогу не получается, попробуйте заключить путь в кавычки ""]. Эта команда создаёт в текущем каталоге новый подкаталог с именем __.git__, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе проект ещё не находится под версионным контролем.
#### Клонирование существующего репозитория
Клонирование репозитория осуществляется командой `git clone`. Есть несколько способ клонировать репозиторий, но мы воспользуемся SSH-ключём. Посмотрите [видео](https://www.youtube.com/watch?v=4evR80g--9k&list=PLg5SS_4L6LYstwxTEOU05E0URTHnbtA0l&index=10), в котором SSH-ключ генерируется и добавляется в профиль GitHub. C 2:14 до 3:07 клонируется произвольный репозиторий с GitHub, предварительно нужно перейти в нужный каталог.
### Запись изменений
#### Немного теории
Итак, у нас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Нам нужно сделать некоторые изменения и фиксировать «снимки» состояния (snapshots) этих изменений в нашем репозитории каждый раз, когда проект достигает состояния, которое нам хотелось бы сохранить.

Каждый файл в рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые, untracked). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными (unmodified), изменёнными (modified) или подготовленными к коммиту (идексированными, staged). Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.
<p align="center">
  <img src="https://user-images.githubusercontent.com/125132889/221302594-1200b05e-6370-4f1e-a11e-40a010e8f419.png">
</p>

Неотслеживаемые файлы — это всё остальное, любые файлы в нашем рабочем каталоге, которые не входили в наш последний снимок состояния и не подготовлены к коммиту. Если репозиторий склонировать впервые, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек, и мы ничего пока не редактировали.

Как только мы отредактируем файл, Git будет рассматривать их как изменённые, так как мы изменили их с момента последнего коммита. Мы индексируем эти изменения, затем фиксируем (commited) все проиндексированные изменения, а затем цикл повторяется.
#### Определение состояния файлов
Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда `git status`. Если выполнить эту команду сразу после клонирования, выведется что-то вроде этого:
```$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```
Это означает, что у нас чистый рабочий каталог, другими словами — в нем нет отслеживаемых измененных файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь. Наконец, команда сообщает нам, на какой ветке мы находимся, и что она не расходится с веткой на сервере. Пока что это всегда ветка master/main/ветка по умолчанию.

Если мы добавим в проект новый файл, например, README и выполним `git status`, то увидим неотслеживаемый файл вот так:
```
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
```
Понять, что новый файл README неотслеживаемый можно по тому, что он находится в секции «Untracked files» в выводе команды status. Статус Untracked означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые мы и не думали добавлять. Попробуем добавить новый файл README.
#### Отслеживание новых файлов
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add` и название файла (если мы хотим начать отслеживать все изменения, используется `git add .`). `git add`выбирает файл/ы и перемещает его/их в промежуточную область, помечая его для включения в следующий коммит.
```
$ git add README
```
Если снова выполнить команду status, можно увидеть, что файл README теперь отслеживаемый и добавлен в индекс:
```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)

    new file:   README
```
Теперь файл проиндексирован, так как он находится в секции «Changes to be committed». Если выполнить коммит в этот момент, то версия файла, существовавшая на момент выполнения команды `git add`, будет добавлена в историю снимков состояния. Кому не терпится, введите `git commit -m "New Feature"`, а чтобы изменения отобразились в GitHub `git push origin main` (вместо main подставьте нужну ветку). Эти действия выполняются на видео с [3:07](https://youtu.be/4evR80g--9k?list=PLg5SS_4L6LYstwxTEOU05E0URTHnbtA0l&t=187)

Работа продолжается...
# Дополнительные материалы
[Учебник по Git на русском языке](https://git-scm.com/book/ru/v2)
